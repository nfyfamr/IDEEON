"use strict";

var url		= require('url');
var fs		= require('fs');
var qs		= require('querystring');
var path	= require('path');

var CONFIG		= JSON.parse(fs.readFileSync(__dirname + '/config.json').toString());
var MIMETYPE	= JSON.parse(fs.readFileSync(__dirname + '/mimetype.json').toString());

///////////////////////////////////////////////////////////////////////////
// Variables 
///////////////////////////////////////////////////////////////////////////

var routingTable = {};
var sessionTable = {};
var __WEB_ROOT = __dirname;


///////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////

// create sessionID string randomly 
var createSessionId = function() {
	var ssid = "";
	var keys = "abcdefghijklnmopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
	for(var i=0; i<60; i++ ) {
		ssid += keys.charAt(Math.floor(Math.random()*keys.length));
	}
	return ssid;
}

// session constructor function
var Session = function(req) {
	this.ssid	= createSessionId();
	this.ip		= req.ip;
	this.login	= false;
}

var add = function(keyA, func, onMethod) {
	// if keyA is String, keyA will be transformed to Array
	// and if keyA is Array, keyA will stay as Array.
	keyA = keyA.toString().split(',');

	if( keyA.length[0] == "" ) {
		throw new Error("You should pass one or more keys");
	} else if( typeof func !== 'function' ) {
		throw new Error("Argument2 isn't function");
	}

	// like keyA, onMethod is parsed to array and appended to func
	onMethod = onMethod || "";
	onMethod = onMethod.toString().split(',');
	if( onMethod[0] == "" ) {
		onMethod = CONFIG.DEFAULT_ACCEPT_METHOD;
	}

	routingTable[keyA] = routingTable[keyA] || {};
	for( var m in onMethod ) {
		routingTable[keyA][onMethod[m]] = func;
	}

	return "Done";
}

var remove = function(key, method) {
	if( method ) {
		delete routingTable[key][method];
	} else {
		delete routingTable[key];
	}
}

var addEndDataEvent = function(req) {
	var data = "";
	req.on('data', function(chunk) {
		data += chunk;
	});
	req.on('end', function() {
		req.emit('endData', data);
	});
}

var routing = function(req, res) {

	// attach cookie, seesion and ip to req
	var pattern	= new RegExp(/(\d{1,3}\.){3}\d{1,3}/);
	req.ip		= req.connection.remoteAddress.match(pattern)[0];
	req.cookie	= req.headers.cookie ? qs.parse(req.headers.cookie.replace(/ /g, ''), ';') : "";

	// if req haven't session then create new session and set cookie
	if( sessionTable[req.cookie.IDSSID] ) {
		req.session = sessionTable[req.cookie.IDSSID];
	} else {
		var ses = new Session(req);
		sessionTable[ses.ssid] = ses;
		req.session = ses;
		res.setHeader('Set-Cookie', ['IDSSID='+ses.ssid]);
	}

	console.log("[ " + (new Date).toLocaleTimeString() + " ] " + req.ip + "\t" + req.method + "\t" + req.url);

	// add event that invoked when all data are received by post method
	if( req.method == 'POST' || req.method == 'PUT' ) {
		addEndDataEvent(req);
	}
	
	// second argument of url.parse is to parse as queryString
	var parsedURL, requestPath, query;

	parsedURL = url.parse(req.url, true);
	req.query = parsedURL.query;
	requestPath = req.path = parsedURL.pathname;
	if( requestPath.length != 1 && requestPath.endsWith('/') ) {
		requestPath = requestPath.substring(0, requestPath.length-1);
	}

	// req will be routed by path, if path isn't added, basically is set to '*'
	if( routingTable[requestPath] && routingTable[requestPath][req.method] ) {
		routingTable[requestPath][req.method](req, res);
	} else {
		routingTable['*']['GET'](req, res);
	}
}

var print = function() {
	console.log(routingTable);
}

var setWebRoot = function(requestPath) {
	__WEB_ROOT = requestPath;
}

var redirectToErrorPage = function(req, res) {
	routingTable['Error_404'](req, res);
}


///////////////////////////////////////////////////////////////////////////
// Default Options Processing
///////////////////////////////////////////////////////////////////////////

add('Error_404', function(req, res) {
	res.writeHead(200, {'Content-Type': 'text/plain'});
	res.write("request page for '" + req.headers.host + req.url + "' is not found");
	res.end();
});

add(['/'], function(req, res) {
	res.writeHead(200, {'Content-Type': 'text/html'});
	res.end();
});

add('/favicon.ico', function(req, res) {
console.log("favicon req is ignored.");
	res.end();
});

// for unrouted url, default method
add('*', function(req, res) {
	var stat, requestPath, extension;

	requestPath = __WEB_ROOT + req.path;
	extension = path.extname(req.path);
	res.setHeader('Content-Type',  [MIMETYPE[extension.substr(1)]]);


	try {
		stat = fs.statSync(requestPath);
		if( stat.isFile() ) {
			// pipe is asynchronous function. So souldn't use res.end()
			fs.createReadStream(requestPath).pipe(res);
		} else {
			throw new Error("ENOENT");
		}
	} catch( e ) {
		// errno -4058: "ENOENT: no such file or directory"
		if( e.errno == -4058 || e.code == "ENOENT" ) {
			routingTable['Error_404']['GET'](req, res);
		} else {
			console.log(e.message);
		}
	}
});



///////////////////////////////////////////////////////////////////////////
// Exports
///////////////////////////////////////////////////////////////////////////

module.exports = {
	add: add,
	remove: remove,
	routing: routing,
	printRtt: print,
	setWebRoot: setWebRoot,
	ERROR: redirectToErrorPage
}
