"use strict";

var path 	= require('path'),
	fs		= require('fs');


var IP_PATTERN = /^([0-9]{1,3})(\.([0-9]{1,3})){3}$/;


// if name is ip addr then attach prefix 'anonymous/'
var parsingName = function(name) {
	return IP_PATTERN.test(name) ? 'anonymous/'+name : name;
}

// check whether parameter is referncing upper directory path1
var checkUpperDirAccess = function(path1, path2) {
	var tmp = path.join(path1, path2);
	if( !path1 || !tmp.startsWith(path1) || tmp==path1 ) {
		return false;
	}
	return true;
}

// return directory tree from startPath
var exploreDirectoryTree = function thisFunc(startPath) {
	var parent = fs.readdirSync(startPath);

	for( var i=0; i<parent.length; ) {
		if( parent[i].startsWith('.') ) {
			var temp = parent.splice(i);
			temp.shift();
			parent = parent.concat(temp);
			continue;
		}

		if( fs.statSync(path.join(startPath, parent[i])).isDirectory() ) {
			parent[i] = {
				name: parent[i],
				type: 'directory'
			}
			parent[i].child = thisFunc(path.join(startPath, parent[i].name));
		} else {
			parent[i] = {
				name: parent[i],
				type: 'file',
			}
		}

		i++;
	}

	return parent;
}

// check whether path is dirctory
var isDirectory = function(path) {
	try {
		return fs.statSync(path).isDirectory();
	} catch (e) {
		return false;
	}
}

// delete all file and diectory from argPath
var deleteDirAll = function(argPath) {
	var tmp = fs.statSync(argPath);
	if( tmp.isDirectory() ) {
		var childList = fs.readdirSync(argPath);
		for( var i=0; i<childList.length; i++ ) {
			deleteDirAll(path.join(argPath, childList[i]));
		}
		fs.rmdirSync(argPath);
	} else {
		fs.unlinkSync(argPath);
	}
}


// File System Manager
// this handle any filesystem instance
function FSM() {

	// root of all manageing instance
	var fileSystemRoot = "";
	// intance cache table
	var fsInstanceTable = {};
	var fsTree = [];

	this.setFileSystemRoot = function(fsRoot) {
		fileSystemRoot = fsRoot;
		fsTree = exploreDirectoryTree(fileSystemRoot);
	}

	this.getFileSystemRoot = function() {
		return fileSystemRoot;
	}

	// return instance
	this.getInstance = function(instName) {
		instName = parsingName(instName);

		if( !checkUpperDirAccess(fileSystemRoot, instName) ) {
			return null;
		}
		if( !isDirectory(path.join(fileSystemRoot, instName)) ) {
			return null;
		}
		
		fsInstanceTable[instName] = fsInstanceTable[instName] || new Instance(instName);
		return fsInstanceTable[instName];
	}

	// remove instance from instance table
	this.removeInstance = function(instName) {
		delete fsInstanceTable[instName];
	}

	// create dirctory named userName
	this.createUser = function(userName) {
		userName = parsingName(userName);

		if( !checkUpperDirAccess(fileSystemRoot, userName) ) {
			return null;
		}

		try {
			fs.mkdirSync(path.join(fileSystemRoot, userName));
		} catch ( e ) {
			console.log(e);
			return false;
		}
		return this.getInstance(userName);
	}

	// delete directory named userName
	this.deleteUser = function(userName) {
		try {
			deleteDirAll(path.join(fileSystemRoot, userName));
		} catch ( e ) {
			console.log(e);
			return false;
		}
		return true;
	}

	// debuging method
	this.showUsers = function() {
		console.log(fs.readdirSync(fileSystemRoot));
		console.log('anonymous: ' + fs.readdirSync(path.join(fileSystemRoot, 'anonymous')));
	}
		

	// instance class
	function Instance(instName) {
		var self = this;
		var rootPath = path.join(fileSystemRoot, instName);
		var writable = true;
		var solutionList = [];
		var fsTree = [];

		// refresh directory tree of instance
		var updateTree = function() {
			self.fsTree = exploreDirectoryTree(rootPath);
		}
		// refresh solution list of instance
		var updateSolutionList = function() {
			solutionList = [];
			for( var i=0; i<self.fsTree.length; i++ ) {
				solutionList.push(self.fsTree[i].name);
			}
		}

		// initiating instance
		updateTree();
		updateSolutionList();

		// debuging method
		this.showSolutionList = function() {
			updateSolutionList();
			console.log(solutionList);
		}
		// read solution/.type file and return its data
		this.getSolutionType = function(solutionName) {
			if( !checkUpperDirAccess(rootPath, solutionName) ) {
				console.log('getSolutionType');
				return false;
			}

			return String(fs.readFileSync(path.join(rootPath, solutionName, ".type")));
		}
		this.getRootPath = function() {
			return rootPath;
		}
		// return whether instance is writable state
		this.getWritable = function() {
			return writable;
		}
		this.createDirectory = function(relPath) {
			if( !checkUpperDirAccess(rootPath, relPath) ) {
				console.log('createDirectory');
				return false;
			}

			try {
				fs.mkdirSync(path.join(rootPath, relPath));
			} catch ( e ) {
				// errno -17 is EEXIST
				if( e.errno == -17 ) {
					console.log('createDir catch errno -17');
					return false;
				} else {
					console.log('createDir catch');
					return false;
				}
			}
		
			updateTree();
			return true;
		}
		this.deleteDirectory = function(relPath) {
			if( !checkUpperDirAccess(rootPath, relPath) ) {
				console.log('deleteDirectory');
				return false;
			}

			try {
				deleteDirAll(path.join(rootPath, relPath));
			} catch ( e ) {
				// errno -2 is ENOENT
				if( e.errno == -2 ) {
					console.log('deleteDirectory errno -2');
					return false;
				} else {
					console.log('deleteDirectory catch');
					return false;
				}
			}
			updateTree();
			return true;
		}
		this.readFile = function(relPath) {
			if( !checkUpperDirAccess(rootPath, relPath) ) {
				console.log('readFIle');
				return false;
			}

			try {
				return fs.readFileSync(path.join(rootPath, relPath));
			} catch( err ) {
				console.log(err);
				return false;
			}
		}
		// if another file is writing return false
		this.writeFile = function(relPath, data) {
			if( !checkUpperDirAccess(rootPath, relPath) ) {
				console.log('writeFile');
				return false;
			}
			if( writable == false ) {
				console.log('wirteFile writable false');
				return false;
			}

			writable = false;
			try {
				fs.writeFileSync(path.join(rootPath, relPath), data);
				updateTree();
				writable = true;
				return true;
			} catch ( err ) {
				console.log(err);
				writable = true;
				return false;
			}
		}
		this.deleteFile = function(relPath) {
			if( !checkUpperDirAccess(rootPath, relPath) ) {
				console.log('deleteFile');
				return false;
			}

			try {
				fs.unlinkSync(path.join(rootPath, relPath));
			} catch ( e ) {
				if( e.errno == -2 ) {
					console.log('err -2');
					return false;
				} else {
					console.log('delteFile catch');
					return false;
				}
			}
			updateTree();
			return true;
		}
		this.createSolution = function(solutionName, type) {
			var check;
			if( !solutionName.trim() || solutionList[solutionName] ) {
				console.log('createSolution');
				return false;
			}

			// create 
			// solution/header
			//			/src
			//			/res
			//			/src
			//			/.bin
			//			/.type
			solutionList[solutionName] = true;
			check = this.createDirectory(solutionName);
			check = this.createDirectory(solutionName + '/header');
			check = this.createDirectory(solutionName + '/src');
			check = this.createDirectory(solutionName + '/res');
			check = this.createDirectory(solutionName + '/.bin');
			check = this.writeFile(solutionName + '/.type', type);
			updateSolutionList();

			return check;
		}
		this.deleteSolution = function(solutionName) {
			var check;
			if( !solutionList[solutionName] ) {
				console.log('deleteSolution');
				return false;
			}

			solutionList[solutionName] = false;
			check = this.deleteDirectory(solutionName);
			updateSolutionList();
			return check;
		}
	}

}







module.exports = new FSM();
